도커 엔진은 "도커 이미지를 생성하고 컨테이너를 실행하는 핵심 기능"

### 2.1 도커 이미지와 컨테이너
- 도커 이미지는 서비스 운영에 필요한 서버 프로그램, 소스코드 및 라이브러리, 컴파일된 실행 파일을 묶는 형태이고 도커 컨테이너는 이미지를 실행한 상태로, 응용프로그램의 종속성과 함께 응용프로그램 자체를 패키징 or 캡슐화하여 격리된 공간에서 프로세스를 동작시키는 기술
### 2.2 도커 컨테이너 다루기
- 도커 GUI 지원하는 Kitematic
- 대부분의 서비스는 단일프로그램으로 동작하지않고, 여러개가 연결되어 동작하는데 서비스를 한 컨테이너에 설치하는 것보다 각 컨테이너로 설치하면 독립성과 모듈화에 최적
도커 볼륨
- 도커 이미지는 읽기전용 도커 컨테이너는 쓰기가 가능해지는데 변경사항은 별도로 저장해서 각 컨테이너에 정보를 저장 및 보존해서 컨테이너 삭제시 데이터가 날아갈수 있는데 이 단점을 해결하기 위해서 도커 볼륨을 활용
- 호스트와 볼륨 공유, 볼륨 컨테이너 활용, 도커가 관리하는 볼륨 생성
~~~
-v [호스트 공유 디렉토리]:[컨테이너 공유 디렉토리] 
~~~
~~~
-v [볼륨명]:[컨테이너 공유 디렉토리]
~~~
- -v 명령어 대신 -mount 명령어로도 사용 가능

#### 도커 네트워크 구조
![image](https://user-images.githubusercontent.com/38122225/129666867-a40a9289-11e5-4850-b65f-3a2ce1b3561d.png)
<br>
[참조](https://jonnung.dev/docker/2020/02/16/docker_network/)

### docker for windows나 docker for mac의 경우 docker0의 브리지를 사용하지 않음 공식문서를 https://docs.docker.com/desktop/windows/networking/ 참조하며 책을 진행함

#### 브리지 네트워크
- docker0 브리지를 사용하는게 아닌 사용자 정의 브리지를 생성하여 각 컨테이너에 연결
~~~
docker network create --driver bridge [브리지 네트워크 명]
~~~
~~~
--net [브리지 네트워크 명]
~~~

#### 호스트 네트워크
- 네트워크를 호스트로 설정 시 호스트의 네트워크 환경을 그대로 사용 가능
~~~
--net host
~~~

#### 논 네트워크
- 네트워크를 사용 X

#### 컨테이너 네트워크
- 다른 컨테이너의 네트워크 환경을 공유
~~~
--net container:[다른 컨테이너ID]
~~~

#### 브리지 네트워크와 --net-alias
- --net-alias 명령어를 같이쓰면 특정 호스트 이름으로 여러개의 컨테이너에 접근 가능
- 매번 달라지는 IP는 라운드 로빈 방식으로 도커엔진 내장 DNS가 호스트 이름을 --net-alias 설정한 컨테이너로 변환
- 도커의 DNS는 호스트 이름으로 유동적인 컨테이너를 찾을때 사용
~~~
--net-alias [호스트 이름]
~~~

#### MacVLAN 네트워크
- 호스트의 네트워크 인터페이스 카드를 가상화해 물리 네트워크 환경을 컨테이너에게 제공
- 컨테이너는 가상의 맥주소를 가지며, 해당 네트워크에 연결된 다른 장치와의 통신이 가능
- host와는 통신 불가능
↑ 공부하지만 MacVLAN에 대한 이해가 좀 부족함 구글링으로 추후 공부 


#### 컨테이너 로깅
~~~
docker logs [컨테이너 이름 또는 아이디]
~~~
- 기본적으로 Json file 형태로 저장되며, --log-opt 옵션으로 파일 최대 크기 및 파일 개수를 지정 가능

#### syslog 로그
- 유닉스에서 로그를 수집하는 표준 중 하나로, --log-driver=syslog 옵션으로 설정 가능
|운영체제|경로|
|:---:|:---:|
|Ubuntu 14.04|/var/log/syslog|
|CentOS, RHEL|/var/log/messages|
|Ubuntu 16.04, CoreOS|journalctl -u docker.service|

## 책 P65에서 로깅 드라이버를 syslog로 변경해서 컨테이너를 생성하는데 본인은 docker for windows에서 wsl2에서 ubuntu를 설치 후 진행중이였는데 에러발생
![image](https://user-images.githubusercontent.com/38122225/129735168-4dbf67d2-244b-48c3-927d-8d98e3cb23b0.png)
## sudo service rsyslog restart 입력 후하면 정상적으로 로깅 드라이버를 syslog 변경 가능하다.


#### 컨테이너 자원 할당 제한
- 컨테이너를 생성하는 과정에서 옵션을 줘서 자원 할당량을 조정할 수 있다.
- docker inspect 명령어를 통해서 자원 제한을 확인할 수 있다.
- ps aux | grep [프로세스 명]을 통해서 자원 할당량을 볼수 있다.
- htop를 통해서 CPU 정보를 UI로 볼수 있다.

#### 컨테이너 메모리 제한
~~~
--memory="[값]"
~~~
- 버전마다 최소 메모리가 조금씩 다르다.

#### 컨테이너 CPU 제한
~~~
--cpu-shares [값]
~~~
- 컨테이너의 가중치를 설정해서 해당 컨테이너의 CPU를 상대적으로 얼마나 사용할지 나타낸다. 기본 값은 1024로 CPU 할당에서 1을 의미한다.
~~~
--cpuset-cpu=[값]
~~~
- 호스트에 CPU가 여러 개 있을 경우 --cpuset-cpu 옵션을 통해서 특정 CPU만 사용하도록 설정이 가능하다.
- 우분투 기준으로 apt-get install htop 명여러를 통해서 설치 후 htop를 통해서 CPU별 사용량을 확인할 수 있다.
~~~
--cpu-period=[값]
--cpu-quota=[값]
~~~
- CPU 스케줄링 주기를 변경할 수 있다.
- --cpu-period는 기본 100000(100ms)이며, --cpu-quota의 값/ --cpu-period의 값만큼 할당한다.
- period가 100000이고 quota가 25000인 경우 주기를 1/4로 줄여서 성능도 1/4로 감소한다.
~~~
--cpus=[값]
~~~
- --cpu-period와 --cpu-quota와 동일하지만 직관적으로 CPU 갯수를 지정한다.
- 값에 0.5 입력시 50%를 사용한다.

##### Block I/O 제한
- 컨테이너를 생성할 때 옵션 지정이 없으면 파일을 읽고 쓰는 대역폭이 제한되어 있지않은데 --device-write-bps, --device-read-bps, --device-write-iops, --device-read-iops 옵션을 지정해서 입출력 제한이 가능하다. 추가적으로 해당 블로그를 [참조](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=alice_k106&logNo=220899310289) 했다.
좀 이해가 제대로 안되서 나중에 추가로 학습이 필요할거 같다.

### 도커 이미지
- 서비스 운영에 필요한 서버 프로그램, 소스코드 및 라이브러리, 컴파일된 실행 파일을 묶는 형태

#### 도커 이미지 생성
~~~
docker commit [options] [container] [repository:tag]
~~~
- 태그 생략시 자동으로 lastest로 설정되며, 기본적으로 도커 이미지를 생성하는 방법에는 여러가지가 존재하는데 위 방법은 기존에 존재하는 container를 이미지로 만든 방법이다. 이 방식은 추천하지 않으며 주로 Dockerfile을 통해서 이미지를 만드는 방식을 주로 사용한다.

#### 도커 이미지 구조
- 이미지는 쉽게 만들 수 있지만, 효과적으로 다루기 위해선 이미지의 구조 이해가 필요하다.
~~~
docker inspect [이미지 이름:Tag]
~~~
명령어 입력시 나오는 Layers 항목은 16진수 해시값으로 이루어져있으며, 이미지를 커밋할 때 변경 사항들이 레이어에 저장한다.
~~~
-- 이미지가 어떤 레이어로 생성됬는지 출력
docker history [이미지 이름:tag]
~~~
~~~
- 컨테이너가 사용 중인 이미지를 docker rm -f 옵션으로 강제 삭제 시 이미지의 이름이 none 으로 변경되는데, none으로 변한 이미지를 dangling이미지라고 한다.
docker images -f danling=true
~~~
도커 이미지 삭제 시 레이어에 참조되는 경우 Untagged~ 라는 결과값이 표시되는데 실제로 이미지를 삭제하는게 아닌 부여된 이름만 삭제한다는 의미다.

### 도커 이미지 추출
~~~
- docker save 명령어로 이미지의 모든 메타데이터를 포함해 파일로 추출 가능하며, docker load 명령어로 이미지를 로드 시에 이전 이미지와 완전히 동일한 이미지가 생성된다.
docker save -o [추출될 파일명] [이미지 명:TAG]
docker load -i [추출한 파일명]
~~~
위 와 비슷한 명령어로 export, import 명령어가 존재한다.


### 2.4 Dockerfile
- 개발한 애플리케이션을 컨테이너화할땐 컨테이너 생성 환경 설치 후 동작을 확인, 컨테이너를 이미지로 커밋하는 방식 하지만 매번 수작업으로 진행해야하기 때문에 보통 도커에서는 build 명령어를 제공
- build하는 작업을 기록한 것을 Dockerfile이라고 부르며, build 명령어는 Dockerfile을 읽어서 이미지를 생성
- Dockerfile을 사용하면 매번 이미지를 커밋해야하는 귀찮은 일이 줄어들고, 개발도구(깃)를 통해 애플리케이션 빌드 및 배포를 자동화

|명령어|의미|
|:---:|:---|
|FROM|생성할 이미지의 베이스가될 이미지를 의미|
|MAINTAINER|이미지를 생성한 개발자의 정보, 1.13.0 이후로 사용 X|
|LABEL|이미지에 메타데이터 추가, docker inspect 명령어로 이미지 정보에서 확인|
|RUN|이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행|
|ADD|파일을 이미지에 추가|
|WORKDIR|명령어를 실행할 디렉토리를 지정|
|EXPOSE|Dockerfile의 빌드로 생성된 이미지에서 노출할 포트를 설정|
|CMD|컨테이너가 시작될 때마다 실행할 명령어를 설정, Dockerfile에서 한번만 사용가능|
|COPY, ADD|호스트OS에서 파일또는 디렉토리를 컨테이너 안 경로로 복사, ADD의 경우 원격 파일 다운로드 또는 축해제 등과 같은 기능이 존재|
|USER|명령을 실행할 사용자 계정을 설정, RUN, CMD, ENTRYPOINT에 적용|

#### 도커 Port forwaring, Port mapping
- 외부 주소와 내부 주소를 이어주는 역할
- -p [호스트 포트]:[컨테이너 포트]/[프로토콜 유형] 프로토콜 유형은 생략가능 생략시 TCP로 기본 적용
- docker run -p 옵션으로 호스트 포트와 컨테이너 포트를 명시적으로 지정이 가능하지만, Dockerfile의 EXPOSE 명령어는 컨테이너 포트만 지정할 뿐이며, 호스트 포트는 -p 옵션으로 호스트 포트를 명시적으로 지정해주던지 생략시 랜덤 호스트포트가 EXPOSE에 설정한 컨테이너 포트로 매핑
